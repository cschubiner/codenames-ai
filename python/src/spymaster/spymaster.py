"""Spymaster LLM interface for generating candidate clues."""

import json
from dataclasses import dataclass
from pathlib import Path
from typing import Optional

from openai import AsyncOpenAI

from ..game import GameState, Team, CardType, Clue
from ..paths import PROMPTS_DIR
from .schema_builder import build_spymaster_schema


@dataclass
class CandidateClue:
    """A candidate clue generated by the spymaster."""
    clue: str
    number: int
    intended_targets: list[str]
    reasoning: str
    risk_assessment: str

    def to_clue(self, team: Team) -> Clue:
        """Convert to a game Clue object."""
        return Clue(
            word=self.clue,
            number=self.number,
            team=team,
            intended_targets=self.intended_targets,
        )


@dataclass
class SpymasterOutput:
    """Complete output from the spymaster."""
    candidates: list[CandidateClue]


@dataclass
class SpymasterConfig:
    """Configuration for the spymaster."""
    model: str = "gpt-4o"
    prompt_id: str = "spymaster_v1"
    temperature: float = 0.7
    candidates_per_turn: int = 8


class Spymaster:
    """
    LLM-based Codenames spymaster for generating candidate clues.

    The spymaster receives the full board state (including the key)
    and generates K candidate clues. Each candidate includes:
    - The clue word and number
    - The intended target words
    - Reasoning for the connection
    - Risk assessment for potential confusion

    These candidates are then evaluated by simulating guesser behavior
    to select the best clue.
    """

    def __init__(
        self,
        config: SpymasterConfig,
        client: Optional[AsyncOpenAI] = None,
        prompts_dir: Optional[Path] = None,
    ):
        """
        Initialize the spymaster.

        Args:
            config: Spymaster configuration
            client: OpenAI client (creates one if not provided)
            prompts_dir: Directory containing prompt templates
        """
        self.config = config
        self.client = client or AsyncOpenAI()

        if prompts_dir is None:
            prompts_dir = PROMPTS_DIR
        self.prompts_dir = prompts_dir

        self._prompt_template = self._load_prompt()

    def _load_prompt(self) -> str:
        """Load the prompt template."""
        prompt_file = self.prompts_dir / f"{self.config.prompt_id}.txt"
        if not prompt_file.exists():
            raise FileNotFoundError(f"Prompt file not found: {prompt_file}")
        return prompt_file.read_text()

    def _format_prompt(self, state: GameState, team: Team) -> str:
        """Format the prompt with game state information."""
        # Get words by type
        team_words = state.get_remaining_words(team)
        opponent_words = state.get_remaining_words(team.opponent)

        neutral_words = [
            w for w, t, r in zip(state.words, state.key, state.revealed)
            if t == CardType.NEUTRAL and not r
        ]

        assassin_word = next(
            w for w, t in zip(state.words, state.key)
            if t == CardType.ASSASSIN
        )

        revealed_words = [
            f"{w} ({state.key[i].value})"
            for i, (w, r) in enumerate(zip(state.words, state.revealed))
            if r
        ]

        return self._prompt_template.format(
            team=team.value.upper(),
            team_words="\n".join(f"- {w}" for w in team_words),
            opponent_words="\n".join(f"- {w}" for w in opponent_words),
            neutral_words="\n".join(f"- {w}" for w in neutral_words),
            assassin_word=assassin_word,
            revealed_words="\n".join(f"- {w}" for w in revealed_words) or "(none)",
            num_candidates=self.config.candidates_per_turn,
        )

    async def generate_candidates(
        self,
        state: GameState,
        team: Team,
        num_candidates: Optional[int] = None,
        temperature: Optional[float] = None,
    ) -> SpymasterOutput:
        """
        Generate candidate clues for the given board state.

        Args:
            state: Current game state (spymaster sees full key)
            team: The team this spymaster is playing for
            num_candidates: Override number of candidates
            temperature: Override temperature

        Returns:
            SpymasterOutput with list of candidate clues
        """
        num_candidates = num_candidates or self.config.candidates_per_turn
        team_words = state.get_remaining_words(team)

        prompt = self._format_prompt(state, team)
        schema = build_spymaster_schema(team_words, num_candidates)

        response = await self.client.chat.completions.create(
            model=self.config.model,
            messages=[
                {"role": "user", "content": prompt}
            ],
            temperature=temperature or self.config.temperature,
            response_format={
                "type": "json_schema",
                "json_schema": schema,
            },
        )

        # Parse the structured response
        content = response.choices[0].message.content
        data = json.loads(content)

        candidates = [
            CandidateClue(
                clue=c["clue"],
                number=c["number"],
                intended_targets=c["intended_targets"],
                reasoning=c["reasoning"],
                risk_assessment=c["risk_assessment"],
            )
            for c in data["candidates"]
        ]

        return SpymasterOutput(candidates=candidates)

    async def generate_single_clue(
        self,
        state: GameState,
        team: Team,
        temperature: Optional[float] = None,
    ) -> CandidateClue:
        """
        Generate a single clue (convenience method).

        Args:
            state: Current game state
            team: The team this spymaster is playing for
            temperature: Override temperature

        Returns:
            A single CandidateClue
        """
        output = await self.generate_candidates(
            state, team, num_candidates=1, temperature=temperature
        )
        return output.candidates[0]

    def validate_clue(self, clue: CandidateClue, state: GameState) -> list[str]:
        """
        Validate a clue against game rules.

        Args:
            clue: The candidate clue to validate
            state: Current game state

        Returns:
            List of validation errors (empty if valid)
        """
        errors = []

        # Check clue is a single word
        if " " in clue.clue:
            errors.append(f"Clue '{clue.clue}' contains spaces")

        # Check clue is not on the board
        clue_upper = clue.clue.upper()
        for word in state.words:
            if word.upper() == clue_upper:
                errors.append(f"Clue '{clue.clue}' is on the board")
                break

        # Check number is reasonable
        if clue.number < 1 or clue.number > 9:
            errors.append(f"Number {clue.number} is out of range (1-9)")

        # Check intended targets are valid
        unrevealed = set(w.upper() for w in state.get_unrevealed_words())
        for target in clue.intended_targets:
            if target.upper() not in unrevealed:
                errors.append(f"Target '{target}' is not an unrevealed word")

        return errors
